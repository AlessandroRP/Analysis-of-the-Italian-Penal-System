---
title: "R Notebook"
output: html_notebook
editor_options: 
  chunk_output_type: console
---

Data Preparation
```{r}

options(scipen = 99999999)
library(cluster)
library(ComplexUpset)
library(readr)
library(readxl)
library(ggplot2)
library(dplyr)
library(FactoMineR)
library(factoextra)
library(tidyr)
library(dbscan)
library(reshape2)
library(plotly)
# ~

# Caricamento del file Excel
data <- read_excel("[01]DB Esecuzione penale esterna.xlsx", na= '-')

# Sostituzione valori da stringa a numerici
data$"In carico all'inizio dell'anno da periodi precedenti" <- as.numeric(data$"In carico all'inizio dell'anno da periodi precedenti")
data$"Presi in carico nell'anno" <- as.numeric(data$"Presi in carico nell'anno")
data$"Totale soggetti in carico" <- as.numeric(data$"Totale soggetti in carico")
data$"Affidamento in prova al servizio sociale" <- as.numeric(data$"Affidamento in prova al servizio sociale")
data$"Detenzione domiciliare" <- as.numeric(data$"Detenzione domiciliare")
data$Semilibertà <- as.numeric(data$Semilibertà)
data$Semidetenzione <- as.numeric(data$Semidetenzione)
data$"Libertà controllata" <- as.numeric(data$"Libertà controllata")
data$"Detenzione domiciliare sostitutiva" <- as.numeric(data$"Detenzione domiciliare sostitutiva")
data$"Semilibertà sostitutiva" <- as.numeric(data$"Semilibertà sostitutiva")
data$"Lavoro di pubblica utilità sostitutivo" <- as.numeric(data$"Lavoro di pubblica utilità sostitutivo")
data$"Libertà vigilata" <- as.numeric(data$"Libertà vigilata")
data$"Lavoro di pubblica utilità - violazione legge sugli stupefacenti" <- as.numeric(data$"Lavoro di pubblica utilità - violazione legge sugli stupefacenti")
data$"Lavoro di pubblica utilità - violazione codice della strada" <- as.numeric(data$"Lavoro di pubblica utilità - violazione codice della strada")
data$"Sospensione condizionale della pena" <- as.numeric(data$"Sospensione condizionale della pena")
data$"Messa alla prova" <- as.numeric(data$"Messa alla prova")

# Merge colonne Lavoro di pubblica utilità
# Trova le colonne che contengono "Lavoro di pubblica utilità"
utilita_cols <- grep("Lavoro di pubblica utilità", colnames(data), value = TRUE)
# Visualizza le colonne trovate
print(utilita_cols)  
# Crea una nuova colonna come somma di tutte le colonne trovate
data$Lavoro_pubblica_utilita_totale <- rowSums(data[, utilita_cols], na.rm = TRUE)
# Verifica il risultato
head(data[, c(utilita_cols, "Lavoro_pubblica_utilita_totale")])

# Filtraggio colonne 
data <- data[c(1,2,3,4,5,6,7,8,15,19,20)]

# Selezione delle variabili numeriche
data_numeric <- data %>% select(-Region, -Municipality, -Year)

# Sostituzione dei NA con la media delle colonne
data_cleaned <- data_numeric %>%
  mutate(across(everything(), ~ ifelse(is.na(.), mean(., na.rm = TRUE), .)))

```


PCA + Interpretation
```{r}

# Standardizzazione delle variabili numeriche
data_scaled <- scale(data_cleaned)

# Calcolo delle PCA
pca_result <- PCA(data_scaled, graph = FALSE)

# Grafico della varianza spiegata
fviz_eig(pca_result, addlabels = TRUE)
# Biplot per visualizzare le variabili
fviz_pca_var(pca_result, col.var = "black")
# Grafico del contributo delle variabili
fviz_cos2(pca_result, choice = "var", axes = 1:2)
# Biplot con variabili colorate in base al cos²
fviz_pca_var(pca_result, col.var = "cos2",
             gradient.cols = c("black", "orange", "green"),
             repel = TRUE)

#Proiezione delle osservazioni sulle prime due componenti principali
pca_data <- data.frame(pca_result$ind$coord)
ggplot(pca_data, aes(x = Dim.1, y = Dim.2)) +
  geom_point() +
  theme_minimal() +
  labs(title = "Proiezione sulle prime due componenti principali",
       x = "PCA 1", y = "PCA 2")

# Aggiunta colonne Region, Municipality e Year
pca_data$Region <- data$Region
pca_data$Municipality <- data$Municipality
pca_data$Year <- data$Year

# Andiamo a mettere i colori alle occorrenze delle varie regioni
ggplot(pca_data, aes(x = Dim.1, y = Dim.2, color = Region)) +
  geom_point(size = 3) +
  theme_minimal() +
  labs(title = "Proiezione con regioni colorate (palette personalizzata)",
       x = "PCA 1", y = "PCA 2") +
  scale_color_manual(values = c(
    "red", "blue", "green", "orange", "purple", "brown", "pink", "cyan", "yellow", "black",
    "darkred", "darkblue", "darkgreen", "gold", "violet", "chocolate", "turquoise", "gray", "darkorange", "navy"
  ))

# Ora vado ad identificare quali sono le variabili sotto a PCA 1/2/3
# Loadings delle variabili
loadings <- pca_result$var$coord
# Visualizza i loadings per le prime tre componenti
head(loadings[, 1:3])
# Ordina le variabili in base all'importanza per PCA 1
loading_pca1 <- loadings[order(abs(loadings[, 1]), decreasing = TRUE), 1]
# Ordina per PCA 2
loading_pca2 <- loadings[order(abs(loadings[, 2]), decreasing = TRUE), 2]
# Ordina per PCA 3
loading_pca3 <- loadings[order(abs(loadings[, 3]), decreasing = TRUE), 3]
# Visualizza i risultati
loading_pca1
loading_pca2
loading_pca3

# Visualizza il contributo delle variabili per PCA 1 e PCA 2
fviz_pca_var(pca_result, axes = c(1, 2),
             col.var = "contrib",
             gradient.cols = c("blue", "yellow", "red"),
             repel = TRUE) +
  labs(title = "Contributo delle variabili (PCA 1 e PCA 2)")
# Visualizza il contributo per PCA 3
fviz_pca_var(pca_result, axes = c(1, 3),
             col.var = "contrib",
             gradient.cols = c("blue", "yellow", "red"),
             repel = TRUE) +
  labs(title = "Contributo delle variabili (PCA 1 e PCA 3)")

# Funzione per creare un grafico dei loadings per una componente specifica
plot_loadings <- function(loadings_sorted, pca_num) {
  loadings_df <- data.frame(Variable = names(loadings_sorted), Loading = loadings_sorted)
  ggplot(loadings_df, aes(x = reorder(Variable, Loading), y = Loading)) +
    geom_bar(stat = "identity", fill = "skyblue") +
    coord_flip() +  # Per ruotare il grafico
    labs(title = paste("Loadings per PCA", pca_num), x = "Variabili", y = "Loading")
}

# Creazione dei grafici per PCA1, PCA2 e PCA3
plot_loadings(loading_pca1, 1)
plot_loadings(loading_pca2, 2)
plot_loadings(loading_pca3, 3)


# Vediamo se c'è una correlazine in base alla posizione territoriale (Nord, Sud , Centro)
# Calcola i centroidi delle regioni
region_means <- pca_data %>%
  group_by(Region) %>%
  summarise(Dim1_mean = mean(Dim.1), Dim2_mean = mean(Dim.2))
# Visualizza i centroidi per verifica
print(region_means)

# Ora interpretiamo le PC per assegnargli dei significati
# Estrarre le componenti principali
pc_scores <- as.data.frame(pca_result$ind$coord)

# Calcolare la matrice di correlazione tra variabili originali e PC
correlation_matrix <- cor(data_scaled, pc_scores)

# Visualizzare la matrice di correlazione
print(correlation_matrix)
# Osserva quali variabili hanno le correlazioni più forti (positive o negative) con ciascuna PC
# Nel nostro caso:
# PC1 --> Correlazione fortemente positiva con quasi tutte le variabili, in particolare "Totale soggetti in carico" (0.99), "In carico all'inizio dell'anno" (0.98), "Presi in carico nell'anno" (0.98). Questa componente rappresenta probabilmente il volume complessivo di gestione dei soggetti tramite misure alternative, ovvero un indicatore della dimensione totale del carico del sistema.
# PC2 --> Maggiore correlazione positiva con "Lavoro di pubblica utilità totale" (0.64) e Maggiore correlazione negativa con "Detenzione domiciliare" (-0.44). Sembra separare le misure alternative alla detenzione (es., lavoro di pubblica utilità) dalle forme più tradizionali come la detenzione domiciliare. Potrebbe rappresentare la preferenza per soluzioni riabilitative moderne rispetto a quelle tradizionali.

# Riorganizzare la matrice per la visualizzazione
corr_melted <- melt(correlation_matrix)

# Creare la heatmap
ggplot(corr_melted, aes(Var1, Var2, fill = value)) +
  geom_tile() +
  scale_fill_gradient2(low = "blue", high = "red", mid = "white", midpoint = 0) +
  labs(x = "Componenti Principali", y = "Variabili Originali", fill = "Correlazione") +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))

# In base a tali osservazioni rinominiamo le PC
pca_data <- pca_data %>% rename(
  "Volume Sistema Penale Esterno" = Dim.1,
  "Preferenza Soluzioni Riabilitative Moderne" = Dim.2
)

```


K-Mean Clustering
```{r}

# Selezioniamo le PCA 1 e 2
pca_kmeans <- pca_data %>% select(-Region, -Municipality, -Year, -Dim.3, -Dim.4, -Dim.5)

# Verifica numero ottimale di cluster tramite silhouette
fviz_nbclust(pca_kmeans, kmeans, method = "wss")

km.res <- kmeans(pca_kmeans, 2)
sil <- silhouette(km.res$cluster, dist(pca_kmeans))
fviz_silhouette(sil)

km.res <- kmeans(pca_kmeans, 3)
sil <- silhouette(km.res$cluster, dist(pca_kmeans))
fviz_silhouette(sil)

km.res <- kmeans(pca_kmeans, 8)
sil <- silhouette(km.res$cluster, dist(pca_kmeans))
fviz_silhouette(sil)

km.res.2 <- kmeans(pca_kmeans, 3)

fviz_cluster(km.res.2, data = pca_kmeans)+theme_minimal()

# Troviamo la media di ogni cluster
aggregate(pca_kmeans, by=list(cluster=km.res.2$cluster), mean)

final_data_kmeans <- cbind(pca_kmeans, Cluster = km.res.2$cluster)

```


Hierarchical Clustering (per confronto e conferma metodo K-Mean)
```{r}

# Selezioniamo le PCA 1 e 2
pca_hierarchical <- pca_data %>% select(-Region, -Municipality, -Year, -Dim.3, -Dim.4, -Dim.5)

# Definiamo linkage methods
m <- c( "average", "single", "complete", "ward")
names(m) <- c( "average", "single", "complete", "ward")

# Function to compute agglomerative coefficient
ac <- function(x) {
  agnes(pca_hierarchical, method = x)$ac
}

# Calcoliamo agglomerative coefficient per ogni clustering linkage method
sapply(m, ac)

# WARD SEEMS THE BEST IN AGGLOMERATIVE COEFFICIENT

# Perform hierarchical clustering using Ward's minimum variance
clust <- agnes(pca_hierarchical, method = "ward")

# Produce dendrogram
pltree(clust, cex = 0.6, hang = -1, main = "Dendrogram")

# NOW WE NEED TO SELECT THE NUMBER OF CLUSTER (SIMILAR TO THE K IN THE K MEANS)
# WE USE THE GAP STATISTICS

# Calculate gap statistic for each number of clusters (up to 5 clusters)
gap_stat <- clusGap(pca_hierarchical, FUN = hcut, nstart = 25, K.max = 5, B = 50)

# Produce plot of clusters vs. gap statistic
fviz_gap_stat(gap_stat)

# THE HIGHEST GAP STASTISTICS IS IN K=3

# Compute distance matrix
d <- dist(pca_hierarchical, method = "euclidean")
final_clust <- hclust(d, method = "ward.D2" )
groups <- cutree(final_clust, k=3)
plot(final_clust)
rect.hclust(final_clust, k = 3, border = "green")

pca_hierarchical$Region <- pca_data$Region
pca_hierarchical$Municipality <- pca_data$Municipality
pca_hierarchical$Year <- pca_data$Year


final_data_hierarchical <- cbind(pca_hierarchical, cluster = groups)
aggregate(final_data_hierarchical, by=list(cluster=final_data_hierarchical$cluster), mean)

ggplot(final_data_hierarchical) +
  aes(x = `Volume Sistema Penale Esterno`, y = `Preferenza Soluzioni Riabilitative Moderne`, colour = as.factor(cluster)) +
  geom_point(shape = "circle", size = 1.5) +
  theme_minimal()

```


Esempi di grafici interpretativi K-Mean Clustering
```{r}

# Prima di tutto, aggiungiamo le colonne Region, Municipality e Year al dataset per poter fare le visualizzazioni
final_data_kmeans$Region <- pca_data$Region
final_data_kmeans$Municipality <- pca_data$Municipality
final_data_kmeans$Year <- pca_data$Year

# 1. Distribuzione dei Cluster per Regione
ggplot(final_data_kmeans, aes(x = Region, fill = as.factor(Cluster))) +
  geom_bar(position = "dodge") +
  labs(title = "Distribuzione dei Cluster per Regione",
       x = "Regione", y = "Conteggio", fill = "Cluster") +
  theme_minimal()

# 2. Heatmap: Volume Sistema Penale Esterno per Regione e Anno
ggplot(final_data_kmeans, aes(x=Year, y=Region, fill=`Volume Sistema Penale Esterno`)) +
  geom_tile() +
  labs(title="Heatmap: Volume Sistema Penale Esterno per Regione e Anno", x="Anno", y="Regione") +
  scale_fill_gradient(low="white", high="blue") +
  theme_minimal()

# 3. Distribuzione del Volume Sistema Penale Esterno per Regione e Anno", x="Anno", y="Volume Sistema Penale Esterno
p <- ggplot(final_data_kmeans, aes(x=Year, y=`Volume Sistema Penale Esterno`, color=factor(Region))) +
  geom_point() +
  labs(title="Distribuzione del Volume Sistema Penale Esterno per Regione e Anno", x="Anno", y="Volume Sistema Penale Esterno")

ggplotly(p)

# 4. Grafico della distribuzione dei cluster nelle prime due componenti principali
ggplot(final_data_kmeans, aes(x = `Volume Sistema Penale Esterno` , y = `Preferenza Soluzioni Riabilitative Moderne`, color = as.factor(Cluster))) +
  geom_point(size = 3) +
  theme_minimal() +
  labs(title = "Distribuzione dei Cluster sulle Prime Due Componenti Principali",
       x = "Volume Sistema Penale Esterno", y = "Preferenza Soluzioni Riabilitative Moderne", color = "Cluster")

# 5. Boxplot dei cluster per PCA 1, suddivisi per Regione
ggplot(final_data_kmeans, aes(x = as.factor(Cluster), y = `Volume Sistema Penale Esterno`, fill = as.factor(Cluster))) +
  geom_boxplot() +
  theme_minimal() +
  labs(title = "Distribuzione per Cluster: Dimensione 1",
       x = "Cluster", y = "Volume Sistema Penale Esterno") +
  scale_fill_manual(values = c("lightblue", "lightgreen", "lightcoral"))

# 6. Grafico a barre della media di PC1 per ciascun cluster, diviso per Regione
aggregate_data <- final_data_kmeans %>%
  group_by(Cluster, Region) %>%
  summarise(Dimensione1 = mean(`Volume Sistema Penale Esterno`))

ggplot(aggregate_data, aes(x = Region, y = Dimensione1, fill = as.factor(Cluster))) +
  geom_bar(stat = "identity", position = "dodge") +
  theme_minimal() +
  labs(title = "Media di Volume Sistema Penale Esterno per Regione e Cluster",
       x = "Regione", y = "Volume Sistema Penale Esterno") +
  scale_fill_manual(values = c("lightblue", "lightgreen", "lightcoral"))

# 7. Andamento Media di Volume Sistema Penale Esterno per Anno e Cluster
aggregate_year <- final_data_kmeans %>%
  group_by(Cluster, Year) %>%
  summarise(Dimensione1 = mean(`Volume Sistema Penale Esterno`))

ggplot(aggregate_year, aes(x = as.factor(Year), y = Dimensione1, fill = as.factor(Cluster))) +
  geom_bar(stat = "identity", position = "dodge") +
  theme_minimal() +
  labs(title = "Media di Volume Sistema Penale Esterno per Anno e Cluster", x = "Anno", y = "Volume Sistema Penale Esterno") +
  scale_fill_manual(values = c("lightblue", "lightgreen", "lightcoral"))

# 8. Performance delle regioni e municipalità sulle dimensioni 1 e 2 per Anno
performance_by_region_municipality_cluster <- final_data_kmeans %>%
  group_by(Region, Municipality, Year, Cluster) %>%
  summarise(Dim1_mean = mean(`Volume Sistema Penale Esterno`, na.rm = TRUE),
            Dim2_mean = mean(`Preferenza Soluzioni Riabilitative Moderne`, na.rm = TRUE))

# Creiamo il grafico dinamico con plotly e animazione per anno
animated_plot <- plot_ly(performance_by_region_municipality_cluster, 
                         x = ~Dim1_mean, 
                         y = ~Dim2_mean, 
                         color = ~Region, 
                         frame = ~Year,   # Animazione per anno
                         text = ~paste("Municipality:", Municipality, "<br>Year:", Year),
                         hoverinfo = "text",  # Mostra le informazioni al passaggio
                         type = 'scatter', 
                         mode = 'markers', 
                         marker = list(size = 10)) %>%
  layout(title = "Performance delle regioni e municipalità sulle dimensioni 1 e 2 per Anno",
         xaxis = list(title = "Volume Sistema Penale Esterno"),
         yaxis = list(title = "Preferenza Soluzioni Riabilitative Moderne"),
         updatemenus = list(
           list(
             type = 'buttons',
             showactive = FALSE,
             buttons = list(
               list(method = 'animate', args = list(NULL, list(frame = list(duration = 500, redraw = TRUE), mode = 'immediate', transition = list(duration = 300))))  # Animazione fluida
             )
           )
         ))

# Visualizza il grafico animato
animated_plot

# 9. Grafico confronto tra zone di riferimento e cluster (pov centroidi)
# Applica K-means ai centroidi delle regioni
kmeans_regions <- kmeans(region_means[, c("Dim1_mean", "Dim2_mean")], centers = 3)
# Aggiungi i cluster ai dati delle regioni
region_means$Cluster <- as.factor(kmeans_regions$cluster)
ggplot(region_means, aes(x = Dim1_mean, y = Dim2_mean, color = Cluster, label = Region)) +
  geom_point(size = 5) +
  geom_text(vjust = -0.5) +
  theme_minimal() +
  labs(title = "Cluster delle regioni nello spazio PCA",
       x = "Volume Sistema Penale Esterno", y = "Preferenza Soluzioni Riabilitative Moderne")
# Aggiungi la macro-area geografica (Nord, Centro, Sud)
region_means$MacroArea <- case_when(
  region_means$Region %in% c("Lombardia", "Veneto", "Piemonte", "Liguria", "Emilia-Romagna", "Trentino-Alto Adige", "Friuli Venezia Giulia", "Valle d'Aosta") ~ "Nord",
  region_means$Region %in% c("Toscana", "Marche", "Lazio", "Umbria","Abruzzo", "Molise") ~ "Centro",
  region_means$Region %in% c("Campania", "Puglia", "Calabria", "Sicilia", "Sardegna", "Basilicata") ~ "Sud"
)
# Confronta i cluster con le macro-aree
ggplot(region_means, aes(x = Dim1_mean, y = Dim2_mean, color = MacroArea, shape = Cluster)) +
  geom_point(size = 5) +
  geom_text(aes(label = Region), vjust = -0.5) +  # Specifica la colonna 'Region' come etichetta
  theme_minimal() +
  labs(title = "Cluster regionali e macro-aree geografiche",
       x = "PCA 1", y = "PCA 2")

# 10. Distribuzione dei comuni per Regione e Cluster (Anno 2023)
interactive_data <- final_data_kmeans %>%
  filter(Year == 2023) %>%  # Filtra solo l'anno 2023
  select(Municipality, Region, Cluster, `Volume Sistema Penale Esterno`, `Preferenza Soluzioni Riabilitative Moderne`)  # Manteniamo solo le colonne necessarie
# Genera una palette personalizzata per il numero di regioni
  library(RColorBrewer)
  region_colors <- colorRampPalette(brewer.pal(8, "Set2"))(length(unique(interactive_data$Region)))
# Creiamo il grafico interattivo con plotly
interactive_plot <- plot_ly(interactive_data, 
                            x = ~`Volume Sistema Penale Esterno`, 
                            y = ~`Preferenza Soluzioni Riabilitative Moderne`, 
                            color = ~Region,
                            colors = region_colors,
                            symbol = ~as.factor(Cluster), 
                            text = ~paste("Comune:", Municipality, 
                                          "<br>Regione:", Region, 
                                          "<br>Cluster:", Cluster), 
                            hoverinfo = "text",  # Mostra le informazioni al passaggio del mouse
                            type = 'scatter', 
                            mode = 'markers', 
                            marker = list(size = 10)) %>%
  layout(title = "Distribuzione dei comuni per Regione e Cluster (Anno 2023)",
         xaxis = list(title = "Volume Sistema Penale Esterno"),
         yaxis = list(title = "Preferenza Soluzioni Riabilitative Moderne"),
         legend = list(title = list(text = "Regioni e Cluster")))
# Visualizza il grafico interattivo
interactive_plot

```

