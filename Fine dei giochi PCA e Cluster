---
title: "R Notebook"
output: html_notebook
editor_options: 
  chunk_output_type: console
---

Data preparation
```{r}

options(scipen = 99999999)
library(cluster)
library(ComplexUpset)
library(readr)
library(readxl)
library(ggplot2)
library(dplyr)
library(FactoMineR)
library(factoextra)
library(tidyr)
library(dbscan)
library(reshape2)
library(plotly)
# ~

# Caricamento del file Excel
data <- read_excel("[01]DB Esecuzione penale esterna.xlsx", na= '-')

# Sostituzione valori da stringa a numerici
data$"In carico all'inizio dell'anno da periodi precedenti" <- as.numeric(data$"In carico all'inizio dell'anno da periodi precedenti")
data$"Presi in carico nell'anno" <- as.numeric(data$"Presi in carico nell'anno")
data$"Totale soggetti in carico" <- as.numeric(data$"Totale soggetti in carico")
data$"Affidamento in prova al servizio sociale" <- as.numeric(data$"Affidamento in prova al servizio sociale")
data$"Detenzione domiciliare" <- as.numeric(data$"Detenzione domiciliare")
data$Semilibertà <- as.numeric(data$Semilibertà)
data$Semidetenzione <- as.numeric(data$Semidetenzione)
data$"Libertà controllata" <- as.numeric(data$"Libertà controllata")
data$"Detenzione domiciliare sostitutiva" <- as.numeric(data$"Detenzione domiciliare sostitutiva")
data$"Semilibertà sostitutiva" <- as.numeric(data$"Semilibertà sostitutiva")
data$"Lavoro di pubblica utilità sostitutivo" <- as.numeric(data$"Lavoro di pubblica utilità sostitutivo")
data$"Libertà vigilata" <- as.numeric(data$"Libertà vigilata")
data$"Lavoro di pubblica utilità - violazione legge sugli stupefacenti" <- as.numeric(data$"Lavoro di pubblica utilità - violazione legge sugli stupefacenti")
data$"Lavoro di pubblica utilità - violazione codice della strada" <- as.numeric(data$"Lavoro di pubblica utilità - violazione codice della strada")
data$"Sospensione condizionale della pena" <- as.numeric(data$"Sospensione condizionale della pena")
data$"Messa alla prova" <- as.numeric(data$"Messa alla prova")

# Merge colonne Lavoro di pubblica utilità
# Trova le colonne che contengono "Lavoro di pubblica utilità"
utilita_cols <- grep("Lavoro di pubblica utilità", colnames(data), value = TRUE)
# Visualizza le colonne trovate
print(utilita_cols)  
# Crea una nuova colonna come somma di tutte le colonne trovate
data$Lavoro_pubblica_utilita_totale <- rowSums(data[, utilita_cols], na.rm = TRUE)
# Verifica il risultato
head(data[, c(utilita_cols, "Lavoro_pubblica_utilita_totale")])

# Filtraggio colonne 
data <- data[c(1,2,3,4,5,6,7,8,15,19,20)]

# Selezione delle variabili numeriche
data_numeric <- data %>% select(-Region, -Municipality, -Year)

# Sostituzione dei NA con la media delle colonne
data_cleaned <- data_numeric %>%
  mutate(across(everything(), ~ ifelse(is.na(.), mean(., na.rm = TRUE), .)))

```


PCA
```{r}

# Standardizzazione delle variabili numeriche
data_scaled <- scale(data_cleaned)

# Calcolo delle PCA
pca_result <- PCA(data_scaled, graph = FALSE)

# Grafico della varianza spiegata
fviz_eig(pca_result, addlabels = TRUE)
# Biplot per visualizzare le variabili
fviz_pca_var(pca_result, col.var = "black")
# Grafico del contributo delle variabili
fviz_cos2(pca_result, choice = "var", axes = 1:2)
# Biplot con variabili colorate in base al cos²
fviz_pca_var(pca_result, col.var = "cos2",
             gradient.cols = c("black", "orange", "green"),
             repel = TRUE)
#Proiezione delle osservazioni sulle prime due componenti principali
pca_data <- data.frame(pca_result$ind$coord)
ggplot(pca_data, aes(x = Dim.1, y = Dim.2)) +
  geom_point() +
  theme_minimal() +
  labs(title = "Proiezione sulle prime due componenti principali",
       x = "PCA 1", y = "PCA 2")

# Aggiunta colonne Region, Municipality e Year
pca_data$Region <- data$Region
pca_data$Municipality <- data$Municipality
pca_data$Year <- data$Year

# Andiamo a mettere i colori alle occorrenze delle varie regioni (le varie strisce sono gli anni che vengono presi in considerazione)
ggplot(pca_data, aes(x = Dim.1, y = Dim.2, color = Region)) +
  geom_point(size = 3) +
  theme_minimal() +
  labs(title = "Proiezione con regioni colorate (palette personalizzata)",
       x = "PCA 1", y = "PCA 2") +
  scale_color_manual(values = c(
    "red", "blue", "green", "orange", "purple", "brown", "pink", "cyan", "yellow", "black",
    "darkred", "darkblue", "darkgreen", "gold", "violet", "chocolate", "turquoise", "gray", "darkorange", "navy"
  ))

# Ora vado ad identificare quali sono le variabili sotto a PCA 1/2/3
# Loadings delle variabili
loadings <- pca_result$var$coord
# Visualizza i loadings per le prime tre componenti
head(loadings[, 1:3])
# Ordina le variabili in base all'importanza per PCA 1
loading_pca1 <- loadings[order(abs(loadings[, 1]), decreasing = TRUE), 1]
# Ordina per PCA 2
loading_pca2 <- loadings[order(abs(loadings[, 2]), decreasing = TRUE), 2]
# Ordina per PCA 3
loading_pca3 <- loadings[order(abs(loadings[, 3]), decreasing = TRUE), 3]
# Visualizza i risultati
loading_pca1
loading_pca2
loading_pca3

# Visualizza il contributo delle variabili per PCA 1 e PCA 2
fviz_pca_var(pca_result, axes = c(1, 2),
             col.var = "contrib",
             gradient.cols = c("blue", "yellow", "red"),
             repel = TRUE) +
  labs(title = "Contributo delle variabili (PCA 1 e PCA 2)")
# Visualizza il contributo per PCA 3
fviz_pca_var(pca_result, axes = c(1, 3),
             col.var = "contrib",
             gradient.cols = c("blue", "yellow", "red"),
             repel = TRUE) +
  labs(title = "Contributo delle variabili (PCA 1 e PCA 3)")

# Funzione per creare un grafico dei loadings per una componente specifica
plot_loadings <- function(loadings_sorted, pca_num) {
  loadings_df <- data.frame(Variable = names(loadings_sorted), Loading = loadings_sorted)
  ggplot(loadings_df, aes(x = reorder(Variable, Loading), y = Loading)) +
    geom_bar(stat = "identity", fill = "skyblue") +
    coord_flip() +  # Per ruotare il grafico
    labs(title = paste("Loadings per PCA", pca_num), x = "Variabili", y = "Loading")
}

# Creazione dei grafici per PCA1, PCA2 e PCA3
plot_loadings(loading_pca1, 1)
plot_loadings(loading_pca2, 2)
plot_loadings(loading_pca3, 3)


# Vediamo se c'è una correlazine in base alla posizione territoriale (Nord, Sud , Centro)
# Calcola i centroidi delle regioni
region_means <- pca_data %>%
  group_by(Region) %>%
  summarise(Dim1_mean = mean(Dim.1), Dim2_mean = mean(Dim.2))
# Visualizza i centroidi per verifica
print(region_means)

```


K-Mean Clustering
```{r}

# Selezioniamo le PCA 1 e 2
pca_kmeans <- pca_data %>% select(-Region, -Municipality, -Year, -Dim.3, -Dim.4, -Dim.5)

# Verifica numero ottimale di cluster tramite silhouette
fviz_nbclust(pca_kmeans, kmeans, method = "wss")

km.res <- kmeans(pca_kmeans, 2)
sil <- silhouette(km.res$cluster, dist(pca_kmeans))
fviz_silhouette(sil)

km.res <- kmeans(pca_kmeans, 3)
sil <- silhouette(km.res$cluster, dist(pca_kmeans))
fviz_silhouette(sil)

km.res <- kmeans(pca_kmeans, 4)
sil <- silhouette(km.res$cluster, dist(pca_kmeans))
fviz_silhouette(sil)

km.res.2 <- kmeans(pca_kmeans, 2)

fviz_cluster(km.res.2, data = pca_kmeans)+theme_minimal()

# Troviamo la media di ogni cluster
aggregate(pca_kmeans, by=list(cluster=km.res.2$cluster), mean)

final_data_kmeans <- cbind(pca_kmeans, Cluster = km.res.2$cluster)

```


Esempi di grafici interpretativi K-Mean Clustering
```{r}

# Prima di tutto, aggiungiamo la colonna dei cluster al dataset per poter fare le visualizzazioni
pca_data$Cluster <- km.res.2$cluster

# 1. Grafico dei cluster suddivisi per Regione (pov comuni)
ggplot(pca_data, aes(x = Dim.1, y = Dim.3, color = Region)) +
  geom_point(aes(shape = as.factor(Cluster)), size = 3) +
  theme_minimal() +
  labs(title = "Distribuzione dei Cluster Suddivisi per Regione",
       x = "PCA 1", y = "PCA 3", color = "Regione", shape = "Cluster") +
  scale_color_manual(values = c(
    "red", "blue", "green", "orange", "purple", "brown", "pink", "cyan", "yellow", "black",
    "darkred", "darkblue", "darkgreen", "gold", "violet", "chocolate", "turquoise", "gray", "darkorange", "navy"
  ))

# 2. Grafico confronto tra zone di riferimento e cluster (pov centroidi)
# Applica K-means ai centroidi delle regioni
kmeans_regions <- kmeans(region_means[, c("Dim1_mean", "Dim3_mean")], centers = 3)
# Aggiungi i cluster ai dati delle regioni
region_means$Cluster <- as.factor(kmeans_regions$cluster)
ggplot(region_means, aes(x = Dim1_mean, y = Dim3_mean, color = Cluster, label = Region)) +
  geom_point(size = 5) +
  geom_text(vjust = -0.5) +
  theme_minimal() +
  labs(title = "Cluster delle regioni nello spazio PCA",
       x = "PCA 1", y = "PCA 3")
# Aggiungi la macro-area geografica (Nord, Centro, Sud)
region_means$MacroArea <- case_when(
  region_means$Region %in% c("Lombardia", "Veneto", "Piemonte", "Liguria", "Emilia-Romagna", "Trentino-Alto Adige", "Friuli Venezia Giulia", "Valle d'Aosta") ~ "Nord",
  region_means$Region %in% c("Toscana", "Marche", "Lazio", "Umbria","Abruzzo", "Molise") ~ "Centro",
  region_means$Region %in% c("Campania", "Puglia", "Calabria", "Sicilia", "Sardegna", "Basilicata") ~ "Sud"
)
# Confronta i cluster con le macro-aree
ggplot(region_means, aes(x = Dim1_mean, y = Dim3_mean, color = MacroArea, shape = Cluster)) +
  geom_point(size = 5) +
  geom_text(aes(label = Region), vjust = -0.5) +  # Specifica la colonna 'Region' come etichetta
  theme_minimal() +
  labs(title = "Cluster regionali e macro-aree geografiche",
       x = "PCA 1", y = "PCA 3")

# 3. Grafico della distribuzione dei cluster nelle prime due componenti principali
ggplot(pca_data, aes(x = Dim.1, y = Dim.3, color = as.factor(Cluster))) +
  geom_point(size = 3) +
  theme_minimal() +
  labs(title = "Distribuzione dei Cluster sulle Prime Due Componenti Principali",
       x = "PCA 1", y = "PCA 3", color = "Cluster")

# 4. Boxplot dei cluster per variabili specifiche, suddivisi per Regione (CHIEDERE SE TENERE)
ggplot(final_data, aes(x = as.factor(Cluster), y = Dim.1, fill = as.factor(Cluster))) +
  geom_boxplot() +
  theme_minimal() +
  labs(title = "Distribuzione per Cluster: Dimensione 1",
       x = "Cluster", y = "Dimensione 1") +
  scale_fill_manual(values = c("lightblue", "lightgreen", "lightcoral"))

# 5. Grafico a barre della media di una variabile per ciascun cluster, diviso per Regione
final_data$Region <- data$Region
aggregate_data <- final_data %>%
  group_by(Cluster, Region) %>%
  summarise(Dimensione1 = mean(Dim.1))
ggplot(aggregate_data, aes(x = Region, y = Dimensione1, fill = as.factor(Cluster))) +
  geom_bar(stat = "identity", position = "dodge") +
  theme_minimal() +
  labs(title = "Media di Dimensione 1 per Regione e Cluster",
       x = "Regione", y = "Dim 1") +
  scale_fill_manual(values = c("lightblue", "lightgreen", "lightcoral")) +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))

# 6. Confronto tra i cluster per variabili temporali (se la variabile Anno esiste)
final_data$Year <- data$Year
aggregate_year <- final_data %>%
  group_by(Cluster, Year) %>%
  summarise(Dimensione1 = mean(Dim.1))

ggplot(aggregate_year, aes(x = as.factor(Year), y = Dimensione1, fill = as.factor(Cluster))) +
  geom_bar(stat = "identity", position = "dodge") +
  theme_minimal() +
  labs(title = "Media di Dimensione 1 per Anno e Cluster", x = "Anno", y = "Dim 1") +
  scale_fill_manual(values = c("lightblue", "lightgreen", "lightcoral"))
# DALL'ULTIMO GRAFICO DEDUCIAMO CHE L'ANDAMENTO è PRESSOCHè LO STESSO, DI CONSEGUENZA ANDREMO A CONSIDERARE SOLO L'ULTIMO ANNO (2023) COME MODELLO PER CONFRONTO CON ALTRO DB.

# 7. Calcoliamo la media delle dimensioni 1 e 3 per cluster, regione e anno
pca_data$Year<-data$Year
performance_by_region_cluster <- pca_data %>%
  group_by(Region, Year, Cluster) %>%
  summarise(Dim1_mean = mean(Dim.1, na.rm = TRUE),
            Dim3_mean = mean(Dim.3, na.rm = TRUE))
# Creiamo un grafico con ggplot2 per mostrare l'andamento della Dimensione 1 nel tempo, separato per cluster
dim1_plot_cluster <- ggplot(performance_by_region_cluster, aes(x = Year, y = Dim1_mean, color = as.factor(Cluster), group = interaction(Region, Cluster))) +
  geom_line(size = 1) +
  geom_point(size = 2) +
  theme_minimal() +
  labs(title = "Andamento della Dimensione 1 nel tempo per Cluster",
       x = "Anno",
       y = "Media Dimensione 1",
       color = "Cluster") +
  theme(legend.position = "bottom")
  print(dim1_plot_cluster)
# Creiamo un grafico con ggplot2 per mostrare l'andamento della Dimensione 3 nel tempo, separato per cluster
dim3_plot_cluster <- ggplot(performance_by_region_cluster, aes(x = Year, y = Dim3_mean, color = as.factor(Cluster), group = interaction(Region, Cluster))) +
  geom_line(size = 1) +
  geom_point(size = 2) +
  theme_minimal() +
  labs(title = "Andamento della Dimensione 3 nel tempo per Cluster",
       x = "Anno",
       y = "Media Dimensione 3",
       color = "Cluster") +
  theme(legend.position = "bottom")
  print(dim3_plot_cluster)

# Genera una palette personalizzata per il numero di regioni
  library(RColorBrewer)
  region_colors <- colorRampPalette(brewer.pal(8, "Set2"))(length(unique(interactive_data$Region)))  
# 8. Creiamo un dataset interattivo per comuni, regioni e cluster per il 2023

interactive_data <- pca_data %>%
  filter(Year == 2023) %>%  # Filtra solo l'anno 2023
  select(Municipality, Region, Cluster, Dim.1, Dim.3)  # Manteniamo solo le colonne necessarie
# Creiamo il grafico interattivo con plotly
interactive_plot <- plot_ly(interactive_data, 
                            x = ~Dim.1, 
                            y = ~Dim.3, 
                            color = ~Region,
                            colors = region_colors,
                            symbol = ~as.factor(Cluster), 
                            text = ~paste("Comune:", Municipality, 
                                          "<br>Regione:", Region, 
                                          "<br>Cluster:", Cluster), 
                            hoverinfo = "text",  # Mostra le informazioni al passaggio del mouse
                            type = 'scatter', 
                            mode = 'markers', 
                            marker = list(size = 10)) %>%
  layout(title = "Distribuzione dei comuni per Regione e Cluster (Anno 2023)",
         xaxis = list(title = "Dimensione 1"),
         yaxis = list(title = "Dimensione 3"),
         legend = list(title = list(text = "Regioni e Cluster")))
# Visualizza il grafico interattivo
interactive_plot

# 9. Aggiungiamo il raggruppamento per Cluster nei dati
performance_by_region_municipality_cluster <- pca_data %>%
  group_by(Region, Municipality, Year, Cluster) %>%
  summarise(Dim1_mean = mean(Dim.1, na.rm = TRUE),
            Dim3_mean = mean(Dim.3, na.rm = TRUE))

# Creiamo il grafico dinamico con plotly e animazione per anno
animated_plot <- plot_ly(performance_by_region_municipality_cluster, 
                         x = ~Dim1_mean, 
                         y = ~Dim3_mean, 
                         color = ~Region,
                         colors = region_colors,
                         frame = ~Year,   # Animazione per anno
                         text = ~paste("Municipality:", Municipality, 
                                       "<br>Year:", Year, 
                                       "<br>Cluster:", Cluster), # Aggiunto Cluster al tooltip
                         hoverinfo = "text",  # Mostra le informazioni al passaggio
                         type = 'scatter', 
                         mode = 'markers', 
                         marker = list(size = 10)) %>%
  layout(title = "Performance delle regioni e municipalità sulle dimensioni 1 e 3 per Cluster",
         xaxis = list(title = "Dimensione 1"),
         yaxis = list(title = "Dimensione 3"),
         updatemenus = list(
           list(
             type = 'buttons',
             showactive = FALSE,
             buttons = list(
               list(method = 'animate', 
                    args = list(NULL, 
                                list(frame = list(duration = 500, redraw = TRUE), 
                                     mode = 'immediate', 
                                     transition = list(duration = 300))))  # Animazione fluida
             )
           )
         ))

# Visualizza il grafico animato
animated_plot

```
